Naši implementaci projektu reprezentuje nasledovné blokové schéma na slidu. Jak je možné vidět, naše implementace se liší tím, že sémantická analýza je součásti interpretu.

Lexikalí analýza je založena na deterministickém konečnem automatu, jehož vstupem je zdrojový kód programu, v případě našeho zadaní se jedná o jazyk IFJ16, který byl inspirován jazykem JAVA. Lexikální analyzátor je plně řízen syntaktickým analyzátorem. Implementace obsahuje dvě funkce, které umožňují získat token. Funkce GET_TOKEN, která vrací nasledující token a PEEK_TOKEN. PEEK_TOKEN byl speciálně navržen pro usnadnění práce syntaktické analýze a to tak, že se umožňuje podívat o jeden token napřed. Funkce PEEK_TOKEN bude vracet stejný token pokud nebude zavolána funkce GET_TOKEN. Aby jsme zajistili časovou nenáročnost a spolehlivost této funkce, tak při opětovném voláni PEEK_TOKEN se nevracíme s čítací hlavou a znova neanalyzuje kód, nýbrž první získaný token je uložen v struktuře a následně je z ní vrácen syntaktické analýze. PEEK_TOKEN je vo velké míře využívána precedenční analýzou.

Struktura tokenu u naši implementace obsahuje nejen typ tokenu a řetezec v zdrojovém kódu, ale i délku řetezce a řádek, na kterém se daný lexém nachází. Tato vlastnost umožňuje v případe chyby vypsat číslo řádku, na kterém k dané chybě přišlo. Usnadní to hlavně práci programátorovi, který chybu jednodušeji lokalizuje a odstraní. Implementace konečného automatu podporuje i rozšíření BASE.

Dále jsme si připravili jednoduchou demontraci funkce konečného automatu, při načtení plňe kvalifikovaného identifikátoru.